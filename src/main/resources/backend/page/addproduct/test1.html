<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Port References Example</title>
    <script src="path_to_html2canvas/html2canvas.min.js"></script>
    <script type="text/javascript">
        mxBasePath = '../src';
    </script>
    <script type="text/javascript" src="../src/js/mxClient.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        #graphContainer {
            overflow: hidden;
            position: relative;
            flex: 1;
            background-color: #f2f2f2;
            cursor: default;
        }

        #buttonsContainer {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.1);
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 5px;
        }
    </style>
    <style type="text/css">
        body div.mxPopupMenu {
            -webkit-box-shadow: 3px 3px 6px #C0C0C0;
            -moz-box-shadow: 3px 3px 6px #C0C0C0;
            box-shadow: 3px 3px 6px #C0C0C0;
            background: white;
            position: absolute;
            border: 3px solid #e7e7e7;
            padding: 3px;
        }
        body table.mxPopupMenu {
            border-collapse: collapse;
            margin: 0px;
        }
        body tr.mxPopupMenuItem {
            color: black;
            cursor: default;
        }
        body td.mxPopupMenuItem {
            padding: 6px 60px 6px 30px;
            font-family: Arial;
            font-size: 10pt;
        }
        body td.mxPopupMenuIcon {
            background-color: white;
            padding: 0px;
        }
        body tr.mxPopupMenuItemHover {
            background-color: #eeeeee;
            color: black;
        }
        table.mxPopupMenu hr {
            border-top: solid 1px #cccccc;
        }
        table.mxPopupMenu tr {
            font-size: 4pt;
        }
    </style>
    <script type="text/javascript">
        var graph;
        function main(container) {
            mxConstraintHandler.prototype.pointImage = new mxImage('images/dot.gif', 10, 10);
            mxEvent.disableContextMenu(document.body);
            mxConstants.HANDLE_FILLCOLOR = '#99ccff';
            mxConstants.HANDLE_STROKECOLOR = '#0088cf';
            mxConstants.VERTEX_SELECTION_COLOR = '#00a8ff';
            graph = new mxGraph(container);
            graph.setConnectable(true);
            graph.setPortsEnabled(false);
            graph.setTooltips(true);
            graph.getCursorForCell = function (cell) {
                if (cell != null && cell.value != null && cell.vertex == 1) {
                    return 'pointer';
                }
            };

            // 不自定义getTooltipForCell方法，则tooltip默认为cell的value值
            graph.getTooltipForCell = function(cell) {
                // 检查cell的value以确定它是哪一个
                if (cell != null && cell.value != null) {
                    if (cell.value === '白名单购买控制接口') {
                        return "对于某些敏感或高价值的产品，限制只有经过验证的用户或组织才能购买";
                    } else if (cell.value === '产品风险判断接口') {
                        return "对特定产品或服务进行风险评估，筛选推荐购入用户群体。";
                    } else if (cell.value === '用户标签控制接口') {
                        return "为系统管理员或相关授权人员提供管理和分配特定的用户标签";
                    } else if (cell.value === '重复购买控制接口') {
                        return "禁止或限制用户对特定产品或服务的多次购买";
                    } else if (cell.value === '利息计算接口') {
                        return "预定义计算方法、利率和期限参数，返回准确的利息金额或利息率，进行资金规划和决策";
                    } else if (cell.value === '库存锁定接口') {
                        return "暂时锁定特定的库存数量，避免了超卖和库存冲突的风险";
                    } else if (cell.value === '库存释放接口') {
                        return "释放或取消之前锁定的库存数量，恢复或调整相应的库存";
                    } else if (cell.value === '库存更新接口') {
                        return "根据特定的业务操作（如销售、退货、补货等）来实时更新库存数量";
                    } else if (cell.value === '日志录入接口') {
                        return "提供一个标准化的方式，用于应用程序、系统或设备将关键操作、事件或错误信息记录到日志系统中";
                    } else if (cell.value === '证件审查接口') {
                        return "验证和审查用户提交的身份证件或证明文件的真实性、有效性和合规性";
                    }
                }
                // 默认返回
                return "";
            }
            new mxRubberband(graph);
            var edgeStyle = graph.getStylesheet().getDefaultEdgeStyle();
            edgeStyle[mxConstants.STYLE_STROKECOLOR] = '#000000'; // 设置边的颜色为黑色
            edgeStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
            edgeStyle[mxConstants.STYLE_STROKEWIDTH] = '2';       // 设置边的宽度
            edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.OrthConnector;
            var root = graph.getDefaultParent();
            var ports = new Array();
            ports['w'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};
            ports['e'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
            ports['n'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north'};
            ports['s'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south'};
            ports['nw'] = {x: 0, y: 0, perimeter: true, constraint: 'north west'};
            ports['ne'] = {x: 1, y: 0, perimeter: true, constraint: 'north east'};
            ports['sw'] = {x: 0, y: 1, perimeter: true, constraint: 'south west'};
            ports['se'] = {x: 1, y: 1, perimeter: true, constraint: 'south east'};
            var ports2 = new Array();
            ports2['in1'] = {x: 0, y: 0, perimeter: true, constraint: 'west'};
            ports2['in2'] = {x: 0, y: 0.25, perimeter: true, constraint: 'west'};
            ports2['in3'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};
            ports2['in4'] = {x: 0, y: 0.75, perimeter: true, constraint: 'west'};
            ports2['in5'] = {x: 0, y: 1, perimeter: true, constraint: 'west'};
            ports2['out1'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north east'};
            ports2['out2'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
            ports2['out3'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south east'};

            var port3 = new Array();
            port3['top'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north'};
            port3['bottom'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south'};
            port3['left'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};
            port3['right'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
            port3['topLeft'] = {x: 0, y: 0, perimeter: true, constraint: 'north west'};
            port3['topRight'] = {x: 1, y: 0, perimeter: true, constraint: 'north east'};
            port3['bottomLeft'] = {x: 0, y: 1, perimeter: true, constraint: 'south west'};
            port3['bottomRight'] = {x: 1, y: 1, perimeter: true, constraint: 'south east'};

            var diamondPorts = new Array();
            diamondPorts['top'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north'};
            diamondPorts['bottom'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south'};
            diamondPorts['left'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};
            diamondPorts['right'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
            mxRhombus.prototype.getPorts=function (){return diamondPorts;};
            mxTriangle.prototype.getPorts = function() { return ports2; };
            mxEllipse.prototype.getPorts = function(){return port3;};
            mxDoubleEllipse.prototype.getPorts = function(){return port3;};
            // 监听键盘事件
            document.addEventListener('keydown', function(event) {
                if (event.keyCode === 46) {
                    var selectionCells = graph.getSelectionCells();
                    if (selectionCells != null && selectionCells.length > 0) {
                        // 过滤选中的边（edges）并删除它们
                        var edgesToDelete = selectionCells.filter(function(cell) {
                            return graph.getModel().isEdge(cell);
                        });
                        if (edgesToDelete.length > 0) {
                            graph.removeCells(edgesToDelete);
                        }
                    }
                }
            });
            mxEdgeHandler.prototype.isConnectableCell = function(cell) { return graph.connectionHandler.isConnectableCell(cell); };
            graph.view.getTerminalPort = function(state, terminal, source) { return terminal; };
            graph.getAllConnectionConstraints = function(terminal, source) {
                if (terminal != null && terminal.shape != null && terminal.shape.stencil != null) {
                    if (terminal.shape.stencil != null) {
                        return terminal.shape.stencil.constraints;
                    }
                } else if (terminal != null && this.model.isVertex(terminal.cell)) {
                    if (terminal.shape != null) {
                        var ports = terminal.shape.getPorts();
                        var cstrs = new Array();
                        for (var id in ports) {
                            var port = ports[id];
                            var cstr = new mxConnectionConstraint(new mxPoint(port.x, port.y), port.perimeter);
                            cstr.id = id;
                            cstrs.push(cstr);
                        }
                        return cstrs;
                    }
                }
                return null;
            };
            graph.setConnectionConstraint = function(edge, terminal, source, constraint) {
                if (constraint != null) {
                    var key = (source) ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
                    if (constraint == null || constraint.id == null) {
                        this.setCellStyles(key, null, [edge]);
                    } else if (constraint.id != null) {
                        this.setCellStyles(key, constraint.id, [edge]);
                    }
                }
            };
            graph.getConnectionConstraint = function(edge, terminal, source) {
                var key = (source) ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
                var id = edge.style[key];
                if (id != null) {
                    var c =  new mxConnectionConstraint(null, null);
                    c.id = id;
                    return c;
                }
                return null;
            };
            graphGetConnectionPoint = graph.getConnectionPoint;
            graph.getConnectionPoint = function(vertex, constraint) {
                if (constraint.id != null && vertex != null && vertex.shape != null) {
                    var port = vertex.shape.getPorts()[constraint.id];
                    if (port != null) {
                        constraint = new mxConnectionConstraint(new mxPoint(port.x, port.y), port.perimeter);
                    }
                }
                return graphGetConnectionPoint.apply(this, arguments);
            };
            graph.getModel().beginUpdate();
            try {
                var pageWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                var pageHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                var toolW = pageWidth * 0.15, toolH = pageHeight * 0.9;

                var tool = graph.insertVertex(root, null, '模板', 2, 4, toolW, toolH, 'editable=0;fillColor=#FFFFFF;resizable=0;movable=0;selectable=0;rounded=1;strokeColor=#000000;strokeWidth=2');
                var titl = graph.insertVertex(root, null, '原子服务', 2, 4, toolW,toolH*0.05,'editable=0;fillColor=#FFFFFF;resizable=0;movable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v1 = graph.insertVertex(tool, null, '白名单购买控制接口', toolW*0.15, toolH*0.08,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v2 = graph.insertVertex(tool, null, '产品风险判断接口', toolW*0.15, toolH*0.16,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v3 = graph.insertVertex(tool, null, '用户标签控制接口', toolW*0.15, toolH*0.24,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v4 = graph.insertVertex(tool, null, '重复购买控制接口', toolW*0.15, toolH*0.32,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v5 = graph.insertVertex(tool, null, '利息计算接口', toolW*0.15, toolH*0.40,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v6 = graph.insertVertex(tool, null, '库存锁定接口', toolW*0.15, toolH*0.48,toolW*0.7 ,50,'shape=ellipse;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v7 = graph.insertVertex(tool, null, '库存释放接口', toolW*0.15, toolH*0.56,toolW*0.7 ,50,'shape=rhombus;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v8 = graph.insertVertex(tool, null, '库存更新接口', toolW*0.15, toolH*0.64,toolW*0.7 ,50,'shape=rhombus;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v9 = graph.insertVertex(tool, null, '日志录入接口', toolW*0.15, toolH*0.72,toolW*0.7 ,50,'shape=rhombus;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v10 = graph.insertVertex(tool, null, '证件审查接口', toolW*0.15, toolH*0.8,toolW*0.7 ,50,'shape=rhombus;editable=0;fillColor=#FFFFFF;resizable=0;selectable=0;strokeColor=#000000;strokeWidth=2');
                var v11 = graph.insertVertex(tool, null, '结束', toolW*0.3, toolH*0.88,50 ,50,'shape=doubleEllipse;editable=0;fillColor=#000000;resizable=0;strokeColor=#FFFFFF;strokeWidth=2');
                var v12 = graph.insertVertex(root, null, '开始', toolW*4, toolH*0.08,50 ,50,'shape=ellipse;editable=0;fillColor=#000000;resizable=0;strokeColor=#FFFFFF;strokeWidth=2');
                graph.popupMenuHandler.autoExpand = true;

                // Installs context menu
                // Installs context menu
                graph.popupMenuHandler.factoryMethod = function(menu, cell, evt) {

                    if (cell != null) { // 检查是否点击了一个单元格（顶点或边）
                        if (graph.getModel().isVertex(cell) && (cell.value !== '模板' && cell.value !== '原子服务')) { // 检查是否点击的是顶点
                            menu.addItem('从流程中移除', null, function() {
                                if (graph.getModel().isVertex(cell)) {
                                    // 删除与顶点相关的所有边
                                    graph.removeCells(graph.getEdges(cell));
                                    var x, y;

                                    // 根据 cell.value 设置不同的位置
                                    switch (cell.value) {
                                        case '白名单购买控制接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.08;
                                            break;
                                        case '地域购买控制接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.16;
                                            break;
                                        case '用户标签控制接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.24;
                                            break;
                                        case '重复购买控制接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.32;
                                            break;
                                        case '利息计算接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.4;
                                            break;
                                        case '库存锁定接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.48;
                                            break;
                                        case '库存释放接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.56;
                                            break;
                                        case '库存更新接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.64;
                                            break;
                                        case '日志录入接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.72;
                                            break;
                                        case '证件审查接口':
                                            x = toolW * 0.15;
                                            y = toolH * 0.8;
                                            break;
                                        case '结束':
                                            x = toolW * 0.3;
                                            y = toolH * 0.88;
                                            break;
                                        default:
                                            x = 200; // 默认位置
                                            y = 200;
                                            break;
                                    }

                                    // 设置顶点的位置
                                    var geometry = cell.getGeometry().clone();
                                    geometry.x = x;
                                    geometry.y = y;
                                    graph.getModel().setGeometry(cell, geometry);

                                    // 刷新图形显示
                                    graph.refresh();
                                }
                            });
                            menu.addItem('锁定/解锁', null, function() {
                                if (graph.getModel().isVertex(cell)) {
                                    // 切换顶点的锁定状态
                                    var state = graph.view.getState(cell);
                                    if (state != null) {
                                        var style = state.style;
                                        var movable = mxUtils.getValue(style, mxConstants.STYLE_MOVABLE, '1') == '0' ? 1 : 0;

                                        // 更新样式中的可移动属性
                                        graph.setCellStyles(mxConstants.STYLE_MOVABLE, movable, [cell]);
                                    }
                                }
                            });
                            // menu.addItem('Edit Vertex', null, function() {
                            //   // 在此处添加编辑顶点的操作，例如打开一个模态框
                            //   alert('Edit Vertex: ' + cell.value);
                            // });
                        } else if (graph.getModel().isEdge(cell)) { // 检查是否点击的是边
                            const currentStyle = graph.getModel().getStyle(cell);
                            menu.addItem('删除', null, function() {
                                graph.getModel().remove(cell);
                            });
                            menu.addItem('直线/折线', null, function() {
                                if (currentStyle.includes('edgeStyle=straight;')) {
                                    graph.getModel().setStyle(cell, currentStyle.replace('edgeStyle=straight;', '')); // 移除直线样式
                                } else {
                                    graph.getModel().setStyle(cell, 'edgeStyle=straight;' + currentStyle); // 添加直线样式
                                }
                            });
                            menu.addItem('虚/实', null, function() {
                                if (currentStyle.includes('dashed=1;')) {
                                    graph.getModel().setStyle(cell, currentStyle.replace('dashed=1;', '')); // 移除虚线样式
                                } else {
                                    graph.getModel().setStyle(cell, currentStyle + 'dashed=1;'); // 添加虚线样式
                                }
                            });


                        }
                    } else { // 如果点击的是空白区域，你可以添加一些默认的菜单项
                        menu.addItem('Default Option 1', null, function() {
                            alert('Default Option 1 for empty space');
                        });
                        menu.addItem('Default Option 2', null, function() {
                            alert('Default Option 2 for empty space');
                        });
                    }
                };


            } finally {
                graph.getModel().endUpdate();
            }
        }
        function saveGraph() {
            // 获取用户输入的名称
            var graphName = prompt("请输入图形名称:", "默认名称");

            // 如果用户点击了取消或没有输入名称，则退出函数
            if (!graphName) return;

            // 获取图形容器的 DOM 元素
            var graphContainer = document.getElementById('graphContainer');

            // 计算页面宽度的30%作为x的值
            var xValue = window.innerWidth * 0.16;

            // 设置html2canvas的配置选项，使用计算出的x值
            var options = {
                x: xValue,
                width: xValue * 5,
            };

            // 使用 html2canvas 从图形容器创建截图
            html2canvas(graphContainer, options).then(function (canvas) {
                // 创建一个链接元素用于下载
                var link = document.createElement('a');

                // 设置下载文件名为用户输入的名称
                link.download = graphName + '.png';

                // 设置图像数据为链接的 href 属性值
                link.href = canvas.toDataURL();

                // 模拟点击链接以触发下载
                link.click();
            });
        }
        function exportGraphToXML() {
            var graphName = prompt("请输入图形名称:", "默认名称");

            // 如果用户点击了取消或没有输入名称，则退出函数
            if (!graphName) return;
            // 获取当前图形的XML表示
            var encoder = new mxCodec();
            var node = encoder.encode(graph.getModel());

            // 将XML数据转换为字符串
            var xml = mxUtils.getPrettyXml(node);

            // 创建一个Blob对象，用于保存XML数据
            var blob = new Blob([xml], { type: 'application/xml' });

            // 创建一个下载链接
            var link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            // link.download = 'graph.xml';
            link.download = graphName + '.xml';
            // 模拟点击链接以触发下载
            link.click();
        }

        function resetGraph() {
            window.location.reload();
        }
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const xmlContent = e.target.result;
                loadGraphFromXML(xmlContent);
            };
            reader.readAsText(file);
        }

        function loadGraphFromXML(xmlContent) {
            if (!graph) {
                alert('Graph is not initialized!');
                return;
            }

            const doc = mxUtils.parseXml(xmlContent);
            const codec = new mxCodec(doc);
            codec.decode(doc.documentElement, graph.getModel());
        }
    </script>



</head>
<body onload="main(document.getElementById('graphContainer'))">
<div id="graphContainer"></div>

<div id="buttonsContainer">

    <input type="file" id="fileInput" style="display: none; color: black; border: 1px solid #d8dde3;" accept=".xml" onchange="handleFileSelect(event)">
    <button onclick="document.getElementById('fileInput').click()">加载模板</button>
    <button onclick="exportGraphToXML()" style="background-color: #fd7065; color: black; border: 1px solid #d8dde3;">设为模板</button>
    <button onclick="saveGraph()" style="background-color: #ffc200; color: black; border: 1px solid #d8dde3;">保存</button>
    <button onclick="resetGraph()" style="background-color: black; color: white; border: 1px solid #d8dde3;">重置</button>

</div>
</body>
</html>
